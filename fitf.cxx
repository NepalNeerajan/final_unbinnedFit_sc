/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "fitf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h"

#include "TF1.h"

ClassImp(fitf); 

 fitf::fitf(const char *name, const char *title, 
                        RooAbsReal& _t,
                        RooAbsCategory& _n,
                        RooAbsReal& _N0,
            RooAbsReal& _lamA,
            RooAbsReal& _lamB,
            RooAbsReal& _lamC,
            RooAbsReal& _lamD,
            RooAbsReal& _lamE,
            RooAbsReal& _lamF,
            RooAbsReal& _lamG,
            RooAbsReal& _lamH,
            RooAbsReal& _lamI,
            RooAbsReal& _lamJ,
            RooAbsReal& _lamK,
            RooAbsReal& _lamL,
            RooAbsReal& _p1A,
            RooAbsReal& _p1B,
            RooAbsReal& _p1C,
            RooAbsReal& _p1D,
            RooAbsReal& _p1E,
            RooAbsReal& _p1F,
            RooAbsReal& _p1G,
            RooAbsReal& _p1H,
            RooAbsReal& _p1I,
            RooAbsReal& _p1J,
            RooAbsReal& _p1K,
            RooAbsReal& _p2A,
            RooAbsReal& _p2B,
            RooAbsReal& _p2C,
            RooAbsReal& _p2D,
            RooAbsReal& _p2E,
            RooAbsReal& _p2F,
            RooAbsReal& _p2G,
            RooAbsReal& _p2H,
            RooAbsReal& _p2I,
            RooAbsReal& _p2J,
            RooAbsReal& _p2K,
            RooAbsReal& _neuEff,
            RooAbsReal& _bkg1,
            RooAbsReal& _bkg2,
            RooAbsReal& _bkg3,
            RooAbsReal& _rc1,
            RooAbsReal& _rc2,
   	    RooAbsReal& _neudEff) :
   RooAbsPdf(name,title), 
   t("t","t",this,_t),
   n("n","n",this,_n),
   N0("N0","N0",this,_N0),
   lamA("lamA","lamA",this,_lamA),
lamB("lamB","lamB",this,_lamB),
lamC("lamC","lamC",this,_lamC),
lamD("lamD","lamD",this,_lamD),
lamE("lamE","lamE",this,_lamE),
lamF("lamF","lamF",this,_lamF),
lamG("lamG","lamG",this,_lamG),
lamH("lamH","lamH",this,_lamH),
lamI("lamI","lamI",this,_lamI),
lamJ("lamJ","lamJ",this,_lamJ),
lamK("lamK","lamK",this,_lamK),
lamL("lamL","lamL",this,_lamL),
p1A("p1A","p1A",this,_p1A),
p1B("p1B","p1B",this,_p1B),
p1C("p1C","p1C",this,_p1C),
p1D("p1D","p1D",this,_p1D),
p1E("p1E","p1E",this,_p1E),
p1F("p1F","p1F",this,_p1F),
p1G("p1G","p1G",this,_p1G),
p1H("p1H","p1H",this,_p1H),
p1I("p1I","p1I",this,_p1I),
p1J("p1J","p1J",this,_p1J),
p1K("p1K","p1K",this,_p1K),
p2A("p2A","p2A",this,_p2A),
p2B("p2B","p2B",this,_p2B),
p2C("p2C","p2C",this,_p2C),
p2D("p2D","p2D",this,_p2D),
p2E("p2E","p2E",this,_p2E),
p2F("p2F","p2F",this,_p2F),
p2G("p2G","p2G",this,_p2G),
p2H("p2H","p2H",this,_p2H),
p2I("p2I","p2I",this,_p2I),
p2J("p2J","p2J",this,_p2J),
p2K("p2K","p2K",this,_p2K),
neuEff("neuEff","neuEff",this,_neuEff),
bkg1("bkg1","bkg1",this,_bkg1),
bkg2("bkg2","bkg2",this,_bkg2),
bkg3("bkg3","bkg3",this,_bkg3),
rc1("rc1","rc1",this,_rc1),
rc2("rc2","rc2",this,_rc2),
neudEff("neudEff","neudEff",this,_neudEff)   
 { 
 } 


 fitf::fitf(const fitf& other, const char* name) :  
   RooAbsPdf(other,name), 
   t("t",this,other.t),
   n("n",this,other.n),
   N0("N0",this,other.N0),
lamA("lamA",this,other.lamA),
lamB("lamB",this,other.lamB),
lamC("lamC",this,other.lamC),
lamD("lamD",this,other.lamD),
lamE("lamE",this,other.lamE),
lamF("lamF",this,other.lamF),
lamG("lamG",this,other.lamG),
lamH("lamH",this,other.lamH),
lamI("lamI",this,other.lamI),
lamJ("lamJ",this,other.lamJ),
lamK("lamK",this,other.lamK),
lamL("lamL",this,other.lamL),
p1A("p1A",this,other.p1A),
p1B("p1B",this,other.p1B),
p1C("p1C",this,other.p1C),
p1D("p1D",this,other.p1D),
p1E("p1E",this,other.p1E),
p1F("p1F",this,other.p1F),
p1G("p1G",this,other.p1G),
p1H("p1H",this,other.p1H),
p1I("p1I",this,other.p1I),
p1J("p1J",this,other.p1J),
p1K("p1K",this,other.p1K),
p2A("p2A",this,other.p2A),
p2B("p2B",this,other.p2B),
p2C("p2C",this,other.p2C),
p2D("p2D",this,other.p2D),
p2E("p2E",this,other.p2E),
p2F("p2F",this,other.p2F),
p2G("p2G",this,other.p2G),
p2H("p2H",this,other.p2H),
p2I("p2I",this,other.p2I),
p2J("p2J",this,other.p2J),
p2K("p2K",this,other.p2K),
neuEff("neuEff",this,other.neuEff),
bkg1("bkg1",this,other.bkg1),
bkg2("bkg2",this,other.bkg2),
bkg3("bkg3",this,other.bkg3),
rc1("rc1",this,other.rc1),
rc2("rc2",this,other.rc2),
neudEff("neudEff",this,other.neudEff)   
 {
 }

//WRITE BATEMAN EQUATION HERE
Double_t fitf::funcA(double *x, double *p)const{
    double a = 0;
    a = p[0]*exp(-p[1]*x[0]);
    return a*p[1];
}

Double_t fitf::funcB(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    a = p[0]*(1-p[2]-p[3])*p[1]*(a1/(p[4]-p[1]) + a4/(p[1]-p[4]));
    return a*p[4];
}

Double_t fitf::funcC(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    double a7 = exp(-p[7]*x[0]);
    a = p[0]*(1-p[2]-p[3])*(1-p[5]-p[6])*p[1]*p[4]*(a1/(p[4]-p[1])/(p[7]-p[1]) + a4/(p[1]-p[4])/(p[7]-p[4]) + a7/(p[1]-p[7])/(p[4]-p[7]));
    return a*p[7];
}

Double_t fitf::funcD(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    double a7 = exp(-p[7]*x[0]);
    double a10 = exp(-p[10]*x[0]);
    a = p[0]*(1-p[2]-p[3])*(1-p[5]-p[6])*(1-p[8]-p[9])*p[1]*p[4]*p[7]*(a1/(p[4]-p[1])/(p[7]-p[1])/(p[10]-p[1]) + a4/(p[1]-p[4])/(p[7]-p[4])/(p[10]-p[4]) + a7/(p[1]-p[7])/(p[4]-p[7])/(p[10]-p[7]) + a10/(p[1]-p[10])/(p[7]-p[10])/(p[4]-p[10]));
    return a*p[10];
}

Double_t fitf::funcE(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a13 = exp(-p[13]*x[0]);
    a = p[0]*p[2]*p[1]*(a1/(p[13]-p[1]) + a13/(p[1]-p[13]));
    return a*p[13];
}

Double_t fitf::funcF(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    double a13 = exp(-p[13]*x[0]);
    double a16 = exp(-p[16]*x[0]);
    double A_B_F = p[0]*(1-p[2]-p[3])*p[5]*p[1]*p[4]*(a1/(p[4]-p[1])/(p[16]-p[1]) + a4/(p[1]-p[4])/(p[16]-p[4]) + a16/(p[1]-p[16])/(p[4]-p[16]));
    double A_E_F = p[0]*p[2]*(1-p[14]-p[15])*p[1]*p[13]*(a1/(p[13]-p[1])/(p[16]-p[1]) + a13/(p[1]-p[13])/(p[16]-p[13]) + a16/(p[1]-p[16])/(p[13]-p[16]));
    a = A_B_F + A_E_F;
    return a*p[16];
}

Double_t fitf::funcG(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    double a7 = exp(-p[7]*x[0]);
    double a13 = exp(-p[13]*x[0]);
    double a16 = exp(-p[16]*x[0]);
    double a19 = exp(-p[19]*x[0]);
    double A_B_C_G = p[0]*(1-p[2]-p[3])*(1-p[5]-p[6])*p[8]*p[1]*p[4]*p[7]*(a1/(p[4]-p[1])/(p[7]-p[1])/(p[19]-p[1]) + a4/(p[1]-p[4])/(p[7]-p[4])/(p[19]-p[4]) + a7/(p[4]-p[7])/(p[1]-p[7])/(p[19]-p[7]) + a19/(p[1]-p[19])/(p[4]-p[19])/(p[7]-p[19]));
    double A_B_F_G = p[0]*(1-p[2]-p[3])*p[5]*(1-p[17]-p[18])*p[1]*p[4]*p[16]*(a1/(p[4]-p[1])/(p[16]-p[1])/(p[19]-p[1]) + a4/(p[1]-p[4])/(p[16]-p[4])/(p[19]-p[4]) + a16/(p[4]-p[16])/(p[1]-p[16])/(p[19]-p[16]) + a19/(p[1]-p[19])/(p[4]-p[19])/(p[16]-p[19]));
    double A_E_F_G = p[0]*p[2]*(1-p[14]-p[15])*(1-p[17]-p[18])*p[1]*p[13]*p[16]*(a1/(p[13]-p[1])/(p[16]-p[1])/(p[19]-p[1]) + a13/(p[1]-p[13])/(p[16]-p[13])/(p[19]-p[13]) + a16/(p[13]-p[16])/(p[1]-p[16])/(p[19]-p[16]) + a19/(p[1]-p[19])/(p[13]-p[19])/(p[16]-p[19]));
    a = A_B_C_G + A_B_F_G + A_E_F_G;
    return a*p[19];
}


Double_t fitf::funcH(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a22 = exp(-p[22]*x[0]);
    a = p[0]*p[3]*p[1]*(a1/(p[22]-p[1]) + a22/(p[1]-p[22]));
    return a*p[22];
}

Double_t fitf::funcI(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    double a13 = exp(-p[13]*x[0]);
    double a22 = exp(-p[22]*x[0]);
    double a25 = exp(-p[25]*x[0]);
    double A_B_I = p[0]*(1-p[2]-p[3])*p[6]*p[1]*p[4]*(a1/(p[4]-p[1])/(p[25]-p[1]) + a4/(p[1]-p[4])/(p[25]-p[4]) + a25/(p[1]-p[25])/(p[4]-p[25]));
    double A_E_I = p[0]*p[2]*p[14]*p[1]*p[13]*(a1/(p[13]-p[1])/(p[25]-p[1]) + a13/(p[1]-p[13])/(p[25]-p[13]) + a25/(p[1]-p[25])/(p[13]-p[25]));
    double A_H_I = p[0]*p[3]*(1-p[23]-p[24])*p[1]*p[22]*(a1/(p[22]-p[1])/(p[25]-p[1]) + a22/(p[1]-p[22])/(p[25]-p[22]) + a25/(p[1]-p[25])/(p[22]-p[25]));
    a = A_B_I + A_E_I + A_H_I;
    return a*p[25];
}

Double_t fitf::funcJ(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    double a7 = exp(-p[7]*x[0]);
    double a13 = exp(-p[13]*x[0]);
    double a16 = exp(-p[16]*x[0]);
    double a22 = exp(-p[22]*x[0]);
    double a25 = exp(-p[25]*x[0]);
    double a28 = exp(-p[28]*x[0]);
    double A_B_C_J = p[0]*(1-p[2]-p[3])*(1-p[5]-p[6])*p[9]*p[1]*p[4]*p[7]*(a1/(p[4]-p[1])/(p[7]-p[1])/(p[28]-p[1]) + a4/(p[1]-p[4])/(p[7]-p[4])/(p[28]-p[4]) + a7/(p[4]-p[7])/(p[1]-p[7])/(p[28]-p[7]) + a28/(p[4]-p[28])/(p[7]-p[28])/(p[1]-p[28]));
    double A_B_F_J = p[0]*(1-p[2]-p[3])*p[5]*p[17]*p[1]*p[4]*p[16]*(a1/(p[4]-p[1])/(p[16]-p[1])/(p[28]-p[1]) + a4/(p[1]-p[4])/(p[16]-p[4])/(p[28]-p[4]) + a16/(p[4]-p[16])/(p[1]-p[16])/(p[28]-p[16]) + a28/(p[4]-p[28])/(p[16]-p[28])/(p[1]-p[28]));
    double A_B_I_J = p[0]*(1-p[2]-p[3])*p[6]*(1-p[26]-p[27])*p[1]*p[4]*p[25]*(a1/(p[4]-p[1])/(p[25]-p[1])/(p[28]-p[1]) + a4/(p[1]-p[4])/(p[25]-p[4])/(p[28]-p[4]) + a25/(p[4]-p[25])/(p[1]-p[25])/(p[28]-p[25]) + a28/(p[4]-p[28])/(p[25]-p[28])/(p[1]-p[28]));
    double A_E_F_J = p[0]*p[2]*(1-p[14]-p[15])*p[17]*p[1]*p[13]*p[16]*(a1/(p[13]-p[1])/(p[16]-p[1])/(p[28]-p[1]) + a13/(p[1]-p[13])/(p[16]-p[13])/(p[28]-p[13]) + a16/(p[13]-p[16])/(p[1]-p[16])/(p[28]-p[16]) + a28/(p[13]-p[28])/(p[16]-p[28])/(p[1]-p[28]));
    double A_E_I_J = p[0]*p[2]*p[14]*(1-p[26]-p[27])*p[1]*p[13]*p[25]*(a1/(p[13]-p[1])/(p[25]-p[1])/(p[28]-p[1]) + a13/(p[1]-p[13])/(p[25]-p[13])/(p[28]-p[13]) + a25/(p[13]-p[25])/(p[1]-p[25])/(p[28]-p[25]) + a28/(p[13]-p[28])/(p[25]-p[28])/(p[1]-p[28]));
    double A_H_I_J = p[0]*p[3]*(1-p[23]-p[24])*(1-p[26]-p[27])*p[1]*p[22]*p[25]*(a1/(p[22]-p[1])/(p[25]-p[1])/(p[28]-p[1]) + a22/(p[1]-p[22])/(p[25]-p[22])/(p[28]-p[22]) + a25/(p[22]-p[25])/(p[1]-p[25])/(p[28]-p[25]) + a28/(p[22]-p[28])/(p[25]-p[28])/(p[1]-p[28]));
    a = A_B_C_J + A_B_F_J + A_B_I_J + A_E_F_J + A_E_I_J + A_H_I_J;
    return a*p[28];
}

Double_t fitf::funcK(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a13 = exp(-p[13]*x[0]);
    double a22 = exp(-p[22]*x[0]);
    double a31 = exp(-p[31]*x[0]);
    double A_E_K = p[0]*p[2]*p[15]*p[1]*p[13]*(a1/(p[13]-p[1])/(p[31]-p[1]) + a13/(p[1]-p[13])/(p[31]-p[13]) + a31/(p[13]-p[31])/(p[1]-p[31]));
    double A_H_K = p[0]*p[3]*p[23]*p[1]*p[22]*(a1/(p[22]-p[1])/(p[31]-p[1]) + a22/(p[1]-p[22])/(p[31]-p[22]) + a31/(p[22]-p[31])/(p[1]-p[31]));
    a = A_E_K + A_H_K;
    return a*p[31];
}

Double_t fitf::funcL(double *x, double *p)const{
    double a = 0;
    double a1 = exp(-p[1]*x[0]);
    double a4 = exp(-p[4]*x[0]);
    double a13 = exp(-p[13]*x[0]);
    double a16 = exp(-p[16]*x[0]);
    double a22 = exp(-p[22]*x[0]);
    double a25 = exp(-p[25]*x[0]);
    double a31 = exp(-p[31]*x[0]);
    double a34 = exp(-p[34]*x[0]);
    double A_B_F_L = p[0]*(1-p[2]-p[3])*p[5]*p[18]*p[1]*p[4]*p[16]*(a1/(p[4]-p[1])/(p[16]-p[1])/(p[34]-p[1]) + a4/(p[1]-p[4])/(p[16]-p[4])/(p[34]-p[4]) + a16/(p[4]-p[16])/(p[1]-p[16])/(p[34]-p[16]) + a34/(p[1]-p[34])/(p[16]-p[34])/(p[4]-p[34]));
    double A_B_I_L = p[0]*(1-p[2]-p[3])*p[6]*p[26]*p[1]*p[4]*p[25]*(a1/(p[4]-p[1])/(p[25]-p[1])/(p[34]-p[1]) + a4/(p[1]-p[4])/(p[25]-p[4])/(p[34]-p[4]) + a25/(p[4]-p[25])/(p[1]-p[25])/(p[34]-p[25]) + a34/(p[1]-p[34])/(p[25]-p[34])/(p[4]-p[34]));
    double A_E_F_L = p[0]*p[2]*(1-p[14]-p[15])*p[18]*p[1]*p[13]*p[16]*(a1/(p[13]-p[1])/(p[16]-p[1])/(p[34]-p[1]) + a13/(p[1]-p[13])/(p[16]-p[13])/(p[34]-p[13]) + a16/(p[13]-p[16])/(p[1]-p[16])/(p[34]-p[16]) + a34/(p[1]-p[34])/(p[16]-p[34])/(p[13]-p[34]));
    double A_E_I_L = p[0]*p[2]*p[14]*p[26]*p[1]*p[13]*p[25]*(a1/(p[13]-p[1])/(p[25]-p[1])/(p[34]-p[1]) + a13/(p[1]-p[13])/(p[25]-p[13])/(p[34]-p[13]) + a25/(p[13]-p[25])/(p[1]-p[25])/(p[34]-p[25]) + a34/(p[1]-p[34])/(p[25]-p[34])/(p[13]-p[34]));
    double A_H_I_L = p[0]*p[3]*(1-p[23]-p[24])*p[26]*p[1]*p[22]*p[25]*(a1/(p[22]-p[1])/(p[25]-p[1])/(p[34]-p[1]) + a22/(p[1]-p[22])/(p[25]-p[22])/(p[34]-p[22]) + a25/(p[22]-p[25])/(p[1]-p[25])/(p[34]-p[25]) + a34/(p[1]-p[34])/(p[25]-p[34])/(p[22]-p[34]));
    double A_H_K_L = p[0]*p[3]*p[23]*(1-p[32]-p[33])*p[1]*p[22]*p[31]*(a1/(p[22]-p[1])/(p[31]-p[1])/(p[34]-p[1]) + a22/(p[1]-p[22])/(p[31]-p[22])/(p[34]-p[22]) + a31/(p[22]-p[31])/(p[1]-p[31])/(p[34]-p[31]) + a34/(p[1]-p[34])/(p[31]-p[34])/(p[22]-p[34]));
    a = A_B_F_L + A_B_I_L + A_E_F_L + A_E_I_L + A_H_I_L + A_H_K_L;
    return a*p[34];
}




//NEED TO WORK FROM HERE ON THE GLOBAL FIT PART
//write a function for FT (total decay), and then for FT with one neutron and two neutron using random neutron coincidences and then write on for FT with zero neutron from the algebra of first three
//p[35] is neutron detection efficiency
//p[39] = random one neutron detection factor
//p[40] = random two neutron detection factor

Double_t fitf::FT(double *x, double *p)const{
    double returnVal = p[36];
    double func = funcA(x,p) + funcB(x,p) + funcC(x,p) + funcD(x,p) + funcE(x,p) + funcF(x,p) + funcG(x,p) + funcH(x,p) + funcI(x,p) + funcJ(x,p) + funcK(x,p) + funcL(x,p);
    if(x[0]>0.0) return returnVal += func;
    return returnVal;
}

Double_t fitf::F1NT(double *x, double *p)const{
    double returnVal = p[37];
    double func = (funcA(x,p)*p[2] + funcB(x,p)*p[5] + funcC(x,p)*p[8] + funcD(x,p)*p[11] + funcE(x,p)*p[14] + funcF(x,p)*p[17] + funcG(x,p)*p[20] + funcH(x,p)*p[23] + funcI(x,p)*p[26] + funcJ(x,p)*p[29])*p[35] + 2*p[41]*(1-p[41])*(funcA(x,p)*p[3] + funcB(x,p)*p[6] + funcC(x,p)*p[9] + funcD(x,p)*p[12] + funcE(x,p)*p[15] + funcF(x,p)*p[18] + funcG(x,p)*p[21] + funcH(x,p)*p[24]) + p[39]*FT(x,p);
    //In above function, in the second term, separate parameter p[41] is introduced for this version to include the neutron detection efficiency of each neutron for two delayed neutrons
    if(x[0]>0.0) return returnVal += func;
    return returnVal;
}

Double_t fitf::F2NT(double *x, double *p)const{
    double returnVal = p[38];
    //changed for delayed two neutrons
    double func = p[41]*p[41]*(funcA(x,p)*p[3] + funcB(x,p)*p[6] + funcC(x,p)*p[9] + funcD(x,p)*p[12] + funcE(x,p)*p[15] + funcF(x,p)*p[18] + funcG(x,p)*p[21]+funcH(x,p)*p[24]) + p[40]*FT(x,p) + p[39]*F1NT(x,p);
    if(x[0]>0.0) return returnVal += func;
    return returnVal;
}

Double_t fitf::F0NT(double *x, double *p)const{
    double func = 0;
    func = FT(x,p) - F1NT(x,p) - F2NT(x,p);
    return func;
}


 Double_t fitf::evaluate() const 
 {
     double T[1];
     T[0] = t;
     double p[42];
     p[0] = N0;
     p[1] = lamA;
     p[2] = p1A;
     p[3] = p2A;
     p[4] = lamB;
     p[5] = p1B;
     p[6] = p2B;
     p[7] = lamC;
     p[8] = p1C;
     p[9] = p2C;
     p[10] = lamD;
     p[11] = p1D;
     p[12] = p2D;
     p[13] = lamE;
     p[14] = p1E;
     p[15] = p2E;
     p[16] = lamF;
     p[17] = p1F;
     p[18] = p2F;
     p[19] = lamG;
     p[20] = p1G;
     p[21] = p2G;
     p[22] = lamH;
     p[23] = p1H;
     p[24] = p2H;
     p[25] = lamI;
     p[26] = p1I;
     p[27] = p2I;
     p[28] = lamJ;
     p[29] = p1J;
     p[30] = p2J;
     p[31] = lamK;
     p[32] = p1K;
     p[33] = p2K;
     p[34] = lamL;
     p[35] = neuEff;
     p[36] = bkg1;
     p[37] = bkg2;
     p[38] = bkg3;
     p[39] = rc1;   //one random neutron coincidence
     p[40] = rc2;   //two random neutron coincidence
     p[41] = neudEff; //for each of two delayed neutrons
     double returnVal = abs((n-1)*(n-2)/2)*F0NT(T,p) + abs(n*(n-2))*F1NT(T,p) + abs((n-1)*n/2)*F2NT(T,p);
     return returnVal;
 } 



